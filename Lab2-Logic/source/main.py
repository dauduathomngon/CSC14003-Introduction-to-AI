class Inference:
    def __init__(self) -> None:
        # store a clause which is alpha
        # for example: clause A OR B stored as [A, B]
        self.alpha: list[list[str]] = []

        # list of clause
        self.KB: list[list[str]] = []

        # store all clause generated by pl_resolution() method
        self.output_clauses: list[list[str]] = []

        self.can_entail = False

    # ------------------------------
    # Private method
    # ------------------------------
    def __format_input(self, input: str) -> None:
        """
        All input is in CNF, but if alpha has more than 1 statement, we use AND
        + For example:
            alpha: A OR B
                  -C OR B 
                  -D OR -E 
            => (A OR B) AND (-C OR B) AND (-D OR -E)
        + How to format:
            - First we split AND => [(A OR B), (-C OR B), (-D OR -E)]
            - Then remove all () => [A OR B, -C OR B, -D OR -E]
            - Again split by OR (also sort literal) => [[A, B], [B, -C], [-D, -E]]
        """
        and_remove = input.split(" AND ")

        for i in range(0, len(and_remove)):
            and_remove[i] = and_remove[i].replace("(", "").replace(")", "")

        or_remove = []
        for i in range(0, len(and_remove)):
            or_remove.append(sorted(and_remove[i].split(" OR "), key=lambda x: x[-1]))

        return or_remove

    def __negate_literal(self, literal: str) -> str:
        """
        + Negate each literal
          so -A => A
          or A => -A
        """
        if literal[0] == "-":
            literal = literal[1:]
        else:
            literal = "-" + literal
        return literal

    def __negate_clause(self, clause):
        """
        + Negate statement and convert to cnf
        + For example:
                (A OR B) AND (-C OR B) AND (-D OR -E) 
            => -(A OR B) OR -(-C OR B) OR -(-D OR -E)
            => (-A AND -B) OR (C AND -B) OR (D OR E)
        + Therefore data = [[-A, -B], [C, -B], [D, E]] but [-A, -B] means -A AND -B instead of -A OR -B.
        """
        negate = []
        for sentence in clause:
            negate.append([self.__negate_literal(s) for s in sentence])
        return negate

    def __is_complement_literal(self, literal1: str, literal2: str) -> bool:
        """
        + Check if literal1 is complement of literal2
        + For example:
            A is complement of -A
        """
        return literal1 == self.__negate_literal(literal2)

    def __is_valid_clause(self, clause: list[str]) -> bool:
        """
        + Check if a clause is always true
        + For example:
            A OR -A OR B = TRUE OR B = TRUE
        """
        for i in range (0, len(clause) - 1):
            if self.__is_complement_literal(clause[i], clause[i+1]):
                return True
        return False

    def __factoring(self, clause: list[str]):
        """
        + Remove same literals in clause (called factoring)
        + Sort clause (because of set())
        + For example:
            A OR A OR B => A OR B
        """
        return sorted(list(set(clause)), key=lambda x: x[-1])

    def __distributeAtom(self, literal, clause):
        """
        + This function only distributes a literal and a clause:
        + For example:
            literal = "A"
            clause = "-C"
            => ["A", "-C"]
        + For example:
            literal = "B"
            clause = ["D", "E"]
            => ["B", "D", "E"]
        """
        if type(clause) == str:
            return [literal, clause]
        else:
            return [literal] + clause
    
    def __distributeAndOr(self, clause):
        """
        + We want to apply distribute law for AND over OR
        + For example:
            - (A AND B) OR (C AND D)
                [[A, B], [C, D]]
            => (A OR C) AND (A OR D) AND (B OR C) AND (B OR D)
                [[A, C], [A, D], [B, C], [B, D]]
        """
        if len(clause) == 1:
            # for example: 
            #   clause = [[C, D]] will have length = 1
            #   therefore return [C, D] (clause[0])
            return clause[0]

        # for example:
        #   clause = [[B], [C, D]]
        #   then LHS = [B]
        #   and  RHS = [C, D]
        lhs = clause[0]
        rhs = self.__distributeAndOr(clause[1:])

        # for example:
        #   LHS = [A, B]
        #   RHS = [C, D]
        #   then result = [[A, C], [A, D], [B, C], [B, D]]
        result = []
        for i in range(0, len(lhs)):
            for j in range(0, len(rhs)):
                result.append(self.__distributeAtom(lhs[i], rhs[j]))
        
        return result

    def __can_resolution(self, clause1: list[str], clause2: list[str]) -> bool:
        """
        + Check if we can apply resolution rule to clause1 and clause2
        + For example:
            (A OR -B) apply resolution (B OR C) is true
            (A OR -B) apply resolution (-B OR C) is false
            (A OR -B OR C) apply resolution (-A OR B OR D) is also false
        """
        count = 0
        for i in range(0, len(clause1)):
            for j in range(0, len(clause2)):
                if self.__is_complement_literal(clause1[i], clause2[j]):
                    count += 1
        if count == 1:
            return True
        else:
            return False

    def __apply_resolution(self, clause1: list[str], clause2: list[str]):
        """
        + Apply resolution rule to clause1 and clause2
        + For example:
            (A OR -B) apply (B OR D) => A OR D
        """
        new_clause = sorted(clause1 + clause2, key=lambda x : x[-1])
        idx = 0
        while idx < len(new_clause) - 1:
            if self.__is_complement_literal(new_clause[idx], new_clause[idx+1]):
                new_clause.pop(idx)
                new_clause.pop(idx)
                continue
            idx += 1
        return self.__factoring(new_clause)

    # ------------------------------
    # Public method
    # ------------------------------
    def negate(self, clause):
        """
        + We negate the clause, then transfrom to CNF by distribute AND over OR (also flatten clause)
        + Note: 
          A AND B = [[A], [B]] (after negation) => [[-A, -B]] (use distribute function)
          A OR B = [[A, B]] (after negation)=> [[-A], [-B]] (special case)
          => If len(clause) == 1, we have to handle differently
        """
        if len(clause) == 1:
            result = []
            for arg in clause[0]:
                result.append([self.__negate_literal(arg)])
            return result

        # negate clause
        neg_clause = self.__negate_clause(clause)

        # distribute clause
        distr_clause = self.__distributeAndOr(neg_clause)

        # remove all valid (redundant) clause
        remove_clause = []
        for arg in distr_clause:
            if not self.__is_valid_clause(arg):
                remove_clause.append(arg)

        # finally remove all same literals in clause
        return [self.__factoring(arg) for arg in remove_clause]

    def read_input(self, path):
        try:
            with open(path) as file:
                lines = [" ".join(line.rstrip().split()) for line in file]

            self.alpha = self.__format_input(lines[0])

            # line[1] is number of clause in KB
            self.KB = [self.__format_input(line)[0] for line in lines[2:]]

        except FileNotFoundError:
            print(f"Can't read file {path}")

    def pl_resolution(self):
        """
        Ref: https://en.wikipedia.org/wiki/Resolution_(logic)#A_resolution_technique
        """
        neg_alpha = self.negate(self.alpha)
        axioms = self.KB

        # avoid duplicate clause and all negation of alpha to KB
        for arg in neg_alpha:
            if arg not in axioms:
                axioms.append(arg)

        # start resolution
        while True:
            # before the first loop, output_clauses has no generated clause
            self.output_clauses.append([])

            for i in range(0, len(axioms)):
                for j in range(0, len(axioms)):
                    if self.__can_resolution(axioms[i], axioms[j]):
                        resolve = self.__apply_resolution(axioms[i], axioms[j])
                        # append resolve to ouput_clause
                        if resolve not in self.output_clauses[-1] and resolve not in axioms:
                            self.output_clauses[-1].append(resolve)
                        # if resolve return empty clause then KB can entail alpha
                        if len(resolve) == 0:
                            self.can_entail = True
                            return

            # if we went through all iterations, but we couldn't derive any new sentences, then KB cannot entail alpha
            if len(self.output_clauses[-1]) == 0:
                self.can_entail = False
                return

            # add all resolve clause to axioms (or KB)
            axioms += self.output_clauses[-1]

    def write_output(self, path):
        with open(path, mode="w") as f:
            for iter in self.output_clauses:
                f.write(str(len(iter)) + "\n")
                # KB cannot entail alpha case
                if len(iter) == 0:
                    f.write("NO")
                    break
                # otherwise
                for clause in iter:
                    if len(clause) == 0:
                        f.write(r"{}" + "\n")
                        f.write("YES")
                        break
                    f.write(" OR ".join(clause) + "\n")


# ------------------------------
# Main function
# ------------------------------
if __name__ == "__main__":
    ie = Inference()
    ie.read_input("input.txt")
    ie.pl_resolution()
    ie.write_output("output.txt")